## 구현
: 주어진 문제를 그대로 따라가며 각 내용에 맞는 코드를 작성하는 기법.
> 모든 알고리즘 문제는 구현으로 풀 수 있다.

: 하지만, 알고리즘 문제는 풀이뿐만 아니라 효율에 큰 비중이 둔다.\
=> 주어진 문제를 풀이한 코드가 얼마나 빠른 시간 안에 예외 상황을 모두 고려해 정확한 출력 값을 가져올 수 있는지 고민해야한다.\
=> __구현만 한다면, 출력 값 가져오기까지 오랜 시간이 걸리거나 예외 사항을 충분히 고려하지 못할 수 있다.__\
=> 이러한 상황을 해결하기 위해 사용되는 여러 가지 알고리즘 기법들이 존재한다!

## 완전탐색
: 컴퓨터의 빠른 연산속도를 이용해, 발생 가능한 모든 경우의 수를 확인하는 방법.
### When?
: 입력으로 주어지는 수가 작은 경우 쉽게 사용가능.
> but, 시간 오래 걸리는 경우가 많으니 시간복잡도 계산 먼저해보기
### How?
#### 1. for문과 if문을 사용하는 반복문
> 재귀 함수에 비해 구현할 수 있는 범위가 매우 제한적인 경우도 있음.
#### 2. 재귀 함수
: 함수 안에서 함수 자기 자신을 다시 호출하는 함수를 의미한다.
``` c++
#include <stdio.h>

int count_down(int second) {
    if(second == 0) { // 기저사례 (재귀함수의 끝)
        return 0;
    }
    else {
        printf("%d초", second);
        count_down(second-1); // 함수안에 함수 사용하기 = 재귀함수
    }
}

int main() {
    count_down(5);

    return 0;
}
```
- 👩‍🏫주의
1. __기저 사례 설정__
: 기저 사례 설정 X => 무한루프
2. __재귀 함수의 깊이가 너무 깊어지지 않도록 주의__
: 함수 호출시 마다 스택 메모리를 사용해 함수와 관련된 데이터를 저장하기 때문에, 데이터 양이 많으면 stack overflow 발생 가능성 있음.\
=> 따라서, 너무 많은 함수 호출이 예상되는 경우, 함수의 호출 횟수를 제한하거나 다른 방식으로 구현하는 등의 접근 방법이 필요.

## 투 포인터(two pointer)
: 정렬된 배열에서 두 개의 포인터(인덱스)를 이용해, 해당 값들과 원하는 값을 비교한 뒤 포인터를 조작해 원하는 결과를 얻어내는 기법.
### 배열 내 합이 S가 되는 순서쌍 찾기
#### 이중 반복문
: 간단하게 구현가능하지만, 시간 초과 발생 가능성이 매우 높아진다.
``` c++
for(int i = 0; i<n; ++1)
    for(int j = i + 1; j<n; ++j)
        if(seq[i] + seq[j] == S)
            cout << seq[i] << '+' << seq[j] << '=' << S << '\n';
```
#### 투 포인터
: 왼쪽 끝 포인터 = l, 오른쪽 끝의 포인터 = r, l <= r가 만족하는 동안 반복하기.
- 두 개의 포인터가 가리키고 있는 원소의 합이 S보다 큰 경우 r을 감소
- 두 개의 포인터가 가리키고 있는 원소의 합이 S보다 작은 경우 l을 증가
- 두 개의  포인터가 가리키고 있는 원소의 합이 S와 같다면, l을 증가시키고 r을 감소시키거나 작업을 종료.
``` c++
#include<vector>
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	int n, s; cin >> n >> s;
	vector<int> seq(n);
	
	for(int i = 0; i<n; ++i)
		cin >> seq[i];
	
	sort(seq.begin(), seq.end());
	
	int l = 0, r = n - 1, ans = 0;
	
	while(l <= r){
		int sum = seq[l] + seq[r];
		if(sum > s) --r;
		else if(sum < s) ++l;
		else{
			++l; --r; ++ans;
		}
	}
	cout << ans; // 합이 s가 되는 순서쌍의 개수
}
```

## 동적 계획법(dynamic programming)
: 어렵거나 큰 문제를 간단하고 작은 여러 개의 문제로 나누어서 풀고 작은 문제의 답들을 이용해 원래 문제의 답을 구하는 방식.
### 특징?
#### 1. 최적 부분 구조
: 문제의 정답이 작은 문제에 대해서도 정답이어야 한다.
> 전체 문제의 정답은 작은 문제들의 정답을 포함해 작은 문제들을 통해 큰 문제를 풀 수 있어야 함.
#### 2. 부분 문제 반복
: 문제를 여러 개의 작은 문제로 나눌 수 있다.
> 나눈 작은 문제들은 전체 문제를 푸는 방법과 같은 방법으로 풀 수 있어야 한다.
### 메모이제이션 기법
: 미리 구해둔 정답을 메모해놓고 만약 다음번에 다시 해당 문제를 풀고자 한다면, 미리 메모해둔 정답을 가져와서 쓰는 기법.
> 똑같은 문제 여러 번 푸는 것 막기.
>> 이러한 조건을 가장 잘 설명해주는 것은 점화식!
### 접근 방법?
: 예시는 피보나치 수 계산
#### 1. 하향식 방법
: 큰 문제를 풀 수 있는 작은 문제가 될 때까지 나눈 후, 작은 문제들을 풀어 얻은 정답들을 합쳐가며 큰 문제의 답을 구하는 방식.\
: __재귀 함수를 이용해 구현__
``` cpp
int d[101010];
int fibo(int n){
	if (n <= 1) return 1;
	int & res = d[n];
	if(res) return res;
	return res = fibo(n - 1) + fibo(n - 2);
}
```
#### 2. 상향식 방법
: 가장 작은 문제부터 시작해, 큰 문제를 풀 수 있을 때까지 차례대로 문제들을 풀어나가는 방식.\
: __반복문을 이용해 구현__
``` cpp
int d[101010] = {1, 1};
for(int i = 2; i<=n; ++i)
	d[i] = d[i-1] + d[i-2];
```