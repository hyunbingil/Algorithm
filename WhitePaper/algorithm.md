## 🛸구현
: 주어진 문제를 그대로 따라가며 각 내용에 맞는 코드를 작성하는 기법.
> 모든 알고리즘 문제는 구현으로 풀 수 있다.

: 하지만, 알고리즘 문제는 풀이뿐만 아니라 효율에 큰 비중이 둔다.\
=> 주어진 문제를 풀이한 코드가 얼마나 빠른 시간 안에 예외 상황을 모두 고려해 정확한 출력 값을 가져올 수 있는지 고민해야한다.\
=> __구현만 한다면, 출력 값 가져오기까지 오랜 시간이 걸리거나 예외 사항을 충분히 고려하지 못할 수 있다.__\
=> 이러한 상황을 해결하기 위해 사용되는 여러 가지 알고리즘 기법들이 존재한다!

## 🛸완전탐색
: 컴퓨터의 빠른 연산속도를 이용해, 발생 가능한 모든 경우의 수를 확인하는 방법.
### When?
: 입력으로 주어지는 수가 작은 경우 쉽게 사용가능.
> but, 시간 오래 걸리는 경우가 많으니 시간복잡도 계산 먼저해보기
### How?
#### 1. for문과 if문을 사용하는 반복문
> 재귀 함수에 비해 구현할 수 있는 범위가 매우 제한적인 경우도 있음.
#### 2. 재귀 함수
: 함수 안에서 함수 자기 자신을 다시 호출하는 함수를 의미한다.
``` c++
#include <stdio.h>

int count_down(int second) {
    if(second == 0) { // 기저사례 (재귀함수의 끝)
        return 0;
    }
    else {
        printf("%d초", second);
        count_down(second-1); // 함수안에 함수 사용하기 = 재귀함수
    }
}

int main() {
    count_down(5);

    return 0;
}
```
- 👩‍🏫주의
1. __기저 사례 설정__
: 기저 사례 설정 X => 무한루프
2. __재귀 함수의 깊이가 너무 깊어지지 않도록 주의__
: 함수 호출시 마다 스택 메모리를 사용해 함수와 관련된 데이터를 저장하기 때문에, 데이터 양이 많으면 stack overflow 발생 가능성 있음.\
=> 따라서, 너무 많은 함수 호출이 예상되는 경우, 함수의 호출 횟수를 제한하거나 다른 방식으로 구현하는 등의 접근 방법이 필요.

## 🛸투 포인터(two pointer)
: 정렬된 배열에서 두 개의 포인터(인덱스)를 이용해, 해당 값들과 원하는 값을 비교한 뒤 포인터를 조작해 원하는 결과를 얻어내는 기법.
### 배열 내 합이 S가 되는 순서쌍 찾기
#### 이중 반복문
: 간단하게 구현가능하지만, 시간 초과 발생 가능성이 매우 높아진다.
``` c++
for(int i = 0; i<n; ++1)
    for(int j = i + 1; j<n; ++j)
        if(seq[i] + seq[j] == S)
            cout << seq[i] << '+' << seq[j] << '=' << S << '\n';
```
#### 투 포인터
: 왼쪽 끝 포인터 = l, 오른쪽 끝의 포인터 = r, l <= r가 만족하는 동안 반복하기.
- 두 개의 포인터가 가리키고 있는 원소의 합이 S보다 큰 경우 r을 감소
- 두 개의 포인터가 가리키고 있는 원소의 합이 S보다 작은 경우 l을 증가
- 두 개의  포인터가 가리키고 있는 원소의 합이 S와 같다면, l을 증가시키고 r을 감소시키거나 작업을 종료.
``` c++
#include<vector>
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	int n, s; cin >> n >> s;
	vector<int> seq(n);
	
	for(int i = 0; i<n; ++i)
		cin >> seq[i];
	
	sort(seq.begin(), seq.end());
	
	int l = 0, r = n - 1, ans = 0;
	
	while(l <= r){
		int sum = seq[l] + seq[r];
		if(sum > s) --r;
		else if(sum < s) ++l;
		else{
			++l; --r; ++ans;
		}
	}
	cout << ans; // 합이 s가 되는 순서쌍의 개수
}
```

## 🛸동적 계획법(dynamic programming)
: 어렵거나 큰 문제를 간단하고 작은 여러 개의 문제로 나누어서 풀고 작은 문제의 답들을 이용해 원래 문제의 답을 구하는 방식.
### 특징?
#### 1. 최적 부분 구조
: 문제의 정답이 작은 문제에 대해서도 정답이어야 한다.
> 전체 문제의 정답은 작은 문제들의 정답을 포함해 작은 문제들을 통해 큰 문제를 풀 수 있어야 함.
#### 2. 부분 문제 반복
: 문제를 여러 개의 작은 문제로 나눌 수 있다.
> 나눈 작은 문제들은 전체 문제를 푸는 방법과 같은 방법으로 풀 수 있어야 한다.
### 메모이제이션 기법
: 미리 구해둔 정답을 메모해놓고 만약 다음번에 다시 해당 문제를 풀고자 한다면, 미리 메모해둔 정답을 가져와서 쓰는 기법.
> 똑같은 문제 여러 번 푸는 것 막기.
>> 이러한 조건을 가장 잘 설명해주는 것은 점화식!
### 접근 방법?
: 예시는 피보나치 수 계산
#### 1. 하향식 방법
: 큰 문제를 풀 수 있는 작은 문제가 될 때까지 나눈 후, 작은 문제들을 풀어 얻은 정답들을 합쳐가며 큰 문제의 답을 구하는 방식.\
: __재귀 함수를 이용해 구현__
``` cpp
int d[101010];
int fibo(int n){
	if (n <= 1) return 1;
	int & res = d[n];
	if(res) return res;
	return res = fibo(n - 1) + fibo(n - 2);
}
```
#### 2. 상향식 방법
: 가장 작은 문제부터 시작해, 큰 문제를 풀 수 있을 때까지 차례대로 문제들을 풀어나가는 방식.\
: __반복문을 이용해 구현__
``` cpp
int d[101010] = {1, 1};
for(int i = 2; i<=n; ++i)
	d[i] = d[i-1] + d[i-2];
```

## 🛸너비 우선 탐색(BFS: Breadth First Search)
: 그래프를 방문하거나 탐색하는 방법은 하나이다.\
: 모든 경로에 대한 동시 탐색이 가능하여 최대 경로를 몰라도 사용할 수 있다는 장점이 있다.\
=> 이로인해 최단거리, 최소비용 등과 같이 최솟값과 관련된 문제를 해결할 수 있다.
> 이때, 그래프의 가중치(시간, 비용, 거리 등)가 1이어야만 한다.
### 탐색 절차
1. 저장된 정점 중 첫 번째 정점을 선택하여 저장된 정점에서 제거.
2. 제거한 정점에서 해야 할 작업 진행.
3. 제거한 정점과 연겨로딘 정점 중 방문하지 않은 모든 정점을 저장.
> 2번 3번 순서가 바뀌어도 상관없다!
4. 저장된 정점에 모든 노드가 제거될 때까지 1~3번 과정 반복.

👩‍🏫 __정점을 저장하고 저장된 정점 중 가장 먼저 저장된 정점을 선택하며 해당 정점에 대한 작업까지의 과정이 반복된다.__
=> 이는 큐 자료구조를 사용해 구현할 수 있다.

### Queue
: FIFO, 가장 먼저 들어온 데이터를 먼저 처리하는 구조.
> stack과는 다르다.
``` c++
void bfs(int start){
	bool chk[1010] = {0};
	queue<int> q;
	
	q.push(start);	//시작점을 큐에 저장
	chk[start] = 1;	//시작점을 방문했다고 표시
	
	while(q.size()){
		int cur = q.front();	//큐에 저장되어 있는 정점 중 가장 먼저 저장된 정점을 선택
		q.pop();	//선택 후 제거
		for(int i = 0; i<adj[cur].size(); ++i){	//해당 정점과 연결된 모든 정점 확인
			int next = adj[cur][i];
			if(!chk[next]){	//만약 해당 정점을 방문하지 않았다면
				chk[next] = 1;	//해당 정점에 방문했다고 표시를 해준 후
				q.push(next);	//큐에 해당 정점을 저장
			}
		}
	}
}
```

## 🛸깊이 우선 탐색(DFS: Depth First Search)
: 그래프를 방문하거나 탐색하는 방법 중 하나.\
: 주로 완전 탐색이나 백트래킹과 같이 탐색의 횟수, 즉 그래프의 최대 경로가 정해져 있거나 예측 가능한 경우에 주로 이용.
> 그래프의 최대 경로(최대 깊이)가 예측할 수 있거나 유한한 범위여야만 사용할 수 있다.

### 탐색 절차
1. 선택한 정점에서 해야 할 작업 진행.
2. 선택한 정점과 연결된 정점 중 아직 방문하지 않은 정점 방문.
3. 만약 더는 방문할 정점이 없다면 이전 정점으로 되돌아감.
4. 1~3번 과정 반복.

### Stack
: DFS는 선택한 정점을 저장하기 위한 도구로 Stack을 이용한다.\
: 스택을 직접 사용하지 않고 주로 스택의 원리를 이용하는 재귀 함수를 통해 구현하는 편.
``` c++
bool chk[1010];
void dfs(int start){
	if(chk[start]) return;	//이미 방문한 정점이라면 함수를 종료
	chk[start] = 1;	//현재 정점을 방문했다고 표시
	
	//인접 리스트를 이용한 그래프
	for(int i = 0; i<adj[start].size(); ++i){	//현재 정점과 연결된 모든 정점을 확인
		int next = adj[start][i];
		dfs(next);
	}
	
	//인접 행렬을 이용한 그래프
	for(int i = 0; i<v; ++i){	//현재 정점과 연결된 모든 정점을 확인
		if(adj[start][i])	//start와 v가 연결된 경우에만 방문
			dfs(v);
	}
}
```