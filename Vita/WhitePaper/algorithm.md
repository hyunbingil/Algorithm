## 🛸구현
: 주어진 문제를 그대로 따라가며 각 내용에 맞는 코드를 작성하는 기법.
> 모든 알고리즘 문제는 구현으로 풀 수 있다.

: 하지만, 알고리즘 문제는 풀이뿐만 아니라 효율에 큰 비중이 둔다.\
=> 주어진 문제를 풀이한 코드가 얼마나 빠른 시간 안에 예외 상황을 모두 고려해 정확한 출력 값을 가져올 수 있는지 고민해야한다.\
=> __구현만 한다면, 출력 값 가져오기까지 오랜 시간이 걸리거나 예외 사항을 충분히 고려하지 못할 수 있다.__\
=> 이러한 상황을 해결하기 위해 사용되는 여러 가지 알고리즘 기법들이 존재한다!

## 🛸완전탐색
: 컴퓨터의 빠른 연산속도를 이용해, 발생 가능한 모든 경우의 수를 확인하는 방법.
### When?
: 입력으로 주어지는 수가 작은 경우 쉽게 사용가능.
> but, 시간 오래 걸리는 경우가 많으니 시간복잡도 계산 먼저해보기
### How?
#### 1. for문과 if문을 사용하는 반복문
> 재귀 함수에 비해 구현할 수 있는 범위가 매우 제한적인 경우도 있음.
#### 2. 재귀 함수
: 함수 안에서 함수 자기 자신을 다시 호출하는 함수를 의미한다.
``` c++
#include <stdio.h>

int count_down(int second) {
    if(second == 0) { // 기저사례 (재귀함수의 끝)
        return 0;
    }
    else {
        printf("%d초", second);
        count_down(second-1); // 함수안에 함수 사용하기 = 재귀함수
    }
}

int main() {
    count_down(5);

    return 0;
}
```
- 👩‍🏫주의
1. __기저 사례 설정__
: 기저 사례 설정 X => 무한루프
2. __재귀 함수의 깊이가 너무 깊어지지 않도록 주의__
: 함수 호출시 마다 스택 메모리를 사용해 함수와 관련된 데이터를 저장하기 때문에, 데이터 양이 많으면 stack overflow 발생 가능성 있음.\
=> 따라서, 너무 많은 함수 호출이 예상되는 경우, 함수의 호출 횟수를 제한하거나 다른 방식으로 구현하는 등의 접근 방법이 필요.

## 🛸투 포인터(two pointer)
: 정렬된 배열에서 두 개의 포인터(인덱스)를 이용해, 해당 값들과 원하는 값을 비교한 뒤 포인터를 조작해 원하는 결과를 얻어내는 기법.
### 배열 내 합이 S가 되는 순서쌍 찾기
#### 이중 반복문
: 간단하게 구현가능하지만, 시간 초과 발생 가능성이 매우 높아진다.
``` c++
for(int i = 0; i<n; ++1)
    for(int j = i + 1; j<n; ++j)
        if(seq[i] + seq[j] == S)
            cout << seq[i] << '+' << seq[j] << '=' << S << '\n';
```
#### 투 포인터
: 왼쪽 끝 포인터 = l, 오른쪽 끝의 포인터 = r, l <= r가 만족하는 동안 반복하기.
- 두 개의 포인터가 가리키고 있는 원소의 합이 S보다 큰 경우 r을 감소
- 두 개의 포인터가 가리키고 있는 원소의 합이 S보다 작은 경우 l을 증가
- 두 개의  포인터가 가리키고 있는 원소의 합이 S와 같다면, l을 증가시키고 r을 감소시키거나 작업을 종료.
``` c++
#include<vector>
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	int n, s; cin >> n >> s;
	vector<int> seq(n);
	
	for(int i = 0; i<n; ++i)
		cin >> seq[i];
	
	sort(seq.begin(), seq.end());
	
	int l = 0, r = n - 1, ans = 0;
	
	while(l <= r){
		int sum = seq[l] + seq[r];
		if(sum > s) --r;
		else if(sum < s) ++l;
		else{
			++l; --r; ++ans;
		}
	}
	cout << ans; // 합이 s가 되는 순서쌍의 개수
}
```

## 🛸동적 계획법(dynamic programming)
: 어렵거나 큰 문제를 간단하고 작은 여러 개의 문제로 나누어서 풀고 작은 문제의 답들을 이용해 원래 문제의 답을 구하는 방식.
### 특징?
#### 1. 최적 부분 구조
: 문제의 정답이 작은 문제에 대해서도 정답이어야 한다.
> 전체 문제의 정답은 작은 문제들의 정답을 포함해 작은 문제들을 통해 큰 문제를 풀 수 있어야 함.
#### 2. 부분 문제 반복
: 문제를 여러 개의 작은 문제로 나눌 수 있다.
> 나눈 작은 문제들은 전체 문제를 푸는 방법과 같은 방법으로 풀 수 있어야 한다.
### 메모이제이션 기법
: 미리 구해둔 정답을 메모해놓고 만약 다음번에 다시 해당 문제를 풀고자 한다면, 미리 메모해둔 정답을 가져와서 쓰는 기법.
> 똑같은 문제 여러 번 푸는 것 막기.
>> 이러한 조건을 가장 잘 설명해주는 것은 점화식!
### 접근 방법?
: 예시는 피보나치 수 계산
#### 1. 하향식 방법
: 큰 문제를 풀 수 있는 작은 문제가 될 때까지 나눈 후, 작은 문제들을 풀어 얻은 정답들을 합쳐가며 큰 문제의 답을 구하는 방식.\
: __재귀 함수를 이용해 구현__
``` cpp
int d[101010];
int fibo(int n){
	if (n <= 1) return 1;
	int & res = d[n];
	if(res) return res;
	return res = fibo(n - 1) + fibo(n - 2);
}
```
#### 2. 상향식 방법
: 가장 작은 문제부터 시작해, 큰 문제를 풀 수 있을 때까지 차례대로 문제들을 풀어나가는 방식.\
: __반복문을 이용해 구현__
``` cpp
int d[101010] = {1, 1};
for(int i = 2; i<=n; ++i)
	d[i] = d[i-1] + d[i-2];
```

## 🛸너비 우선 탐색(BFS: Breadth First Search)
: 그래프를 방문하거나 탐색하는 방법은 하나이다.\
: 모든 경로에 대한 동시 탐색이 가능하여 최대 경로를 몰라도 사용할 수 있다는 장점이 있다.\
=> 이로인해 최단거리, 최소비용 등과 같이 최솟값과 관련된 문제를 해결할 수 있다.
> 이때, 그래프의 가중치(시간, 비용, 거리 등)가 1이어야만 한다.
### 탐색 절차
1. 저장된 정점 중 첫 번째 정점을 선택하여 저장된 정점에서 제거.
2. 제거한 정점에서 해야 할 작업 진행.
3. 제거한 정점과 연겨로딘 정점 중 방문하지 않은 모든 정점을 저장.
> 2번 3번 순서가 바뀌어도 상관없다!
4. 저장된 정점에 모든 노드가 제거될 때까지 1~3번 과정 반복.

👩‍🏫 __정점을 저장하고 저장된 정점 중 가장 먼저 저장된 정점을 선택하며 해당 정점에 대한 작업까지의 과정이 반복된다.__
=> 이는 큐 자료구조를 사용해 구현할 수 있다.

### Queue
: FIFO, 가장 먼저 들어온 데이터를 먼저 처리하는 구조.
> stack과는 다르다.
``` c++
void bfs(int start){
	bool chk[1010] = {0};
	queue<int> q;
	
	q.push(start);	//시작점을 큐에 저장
	chk[start] = 1;	//시작점을 방문했다고 표시
	
	while(q.size()){
		int cur = q.front();	//큐에 저장되어 있는 정점 중 가장 먼저 저장된 정점을 선택
		q.pop();	//선택 후 제거
		for(int i = 0; i<adj[cur].size(); ++i){	//해당 정점과 연결된 모든 정점 확인
			int next = adj[cur][i];
			if(!chk[next]){	//만약 해당 정점을 방문하지 않았다면
				chk[next] = 1;	//해당 정점에 방문했다고 표시를 해준 후
				q.push(next);	//큐에 해당 정점을 저장
			}
		}
	}
}
```

## 🛸깊이 우선 탐색(DFS: Depth First Search)
: 그래프를 방문하거나 탐색하는 방법 중 하나.\
: 주로 완전 탐색이나 백트래킹과 같이 탐색의 횟수, 즉 그래프의 최대 경로가 정해져 있거나 예측 가능한 경우에 주로 이용.
> 그래프의 최대 경로(최대 깊이)가 예측할 수 있거나 유한한 범위여야만 사용할 수 있다.

### 탐색 절차
1. 선택한 정점에서 해야 할 작업 진행.
2. 선택한 정점과 연결된 정점 중 아직 방문하지 않은 정점 방문.
3. 만약 더는 방문할 정점이 없다면 이전 정점으로 되돌아감.
4. 1~3번 과정 반복.

### Stack
: DFS는 선택한 정점을 저장하기 위한 도구로 Stack을 이용한다.\
: 스택을 직접 사용하지 않고 주로 스택의 원리를 이용하는 재귀 함수를 통해 구현하는 편.
``` c++
bool chk[1010];
void dfs(int start){
	if(chk[start]) return;	//이미 방문한 정점이라면 함수를 종료
	chk[start] = 1;	//현재 정점을 방문했다고 표시
	
	//인접 리스트를 이용한 그래프
	for(int i = 0; i<adj[start].size(); ++i){	//현재 정점과 연결된 모든 정점을 확인
		int next = adj[start][i];
		dfs(next);
	}
	
	//인접 행렬을 이용한 그래프
	for(int i = 0; i<v; ++i){	//현재 정점과 연결된 모든 정점을 확인
		if(adj[start][i])	//start와 v가 연결된 경우에만 방문
			dfs(v);
	}
}
```

## 🛸소수 판별하기
: 소수(prime number)는 1과 자기 자신으로만 나누어떨어지는 수를 말한다.
### 방법1
: 임의의 수 N이 소수인지 판별하기 위해서는 보통, 2부터 N-1까지 모든 수로 나누어보면서 나머지가 0인지 아닌지 판단한다.

### 방법2
: __2부터 sqrt{N}까지 나누었을 때 나누어 떨어지지 않으면, 그보다 큰 수로 나누었을 때는 모두 나누어 떨어지지 않는다.__
``` c++
bool prime = 1;
for(int i = 2; i * i <= MAX; ++i){
	if(num % i == 0){
		prime = 0;
		break;
	}
}
if(prime)
	cout << "소수";
else
	cout << "합성수";
```
: sqrt 함수 사용안하고 이 방법으로 하는 것이 더 좋다!\
=> 복잡한 실수 연산을 피할 수 있고, sqrt 함수를 사용하면 시간이 더 걸리기 때문이다!

### 방법3(에라토스테네스의 체)
#### 동작방식
1. 1을 제외한 모든 수를 표에 적는다.
2. 현재 수가 지워져 있다면 다음 수로 넘어간다.
3. 현재 수가 지워져 있지 않다면, 현재 수를 제외한 모든 배수를 지우고 다음 수로 넘어간다.\
=> 반복해서 남은 모든 수는 소수이다.
``` c++
#define MAX_NUM 1000000
bool sieve[MAX_NUM] = {1, 1};	//0: 소수, 1: 합성수
for(int i = 2; i * i <=MAX_NUM; ++i){
	if(sieve[i]) continue;		//이미 지워진 수라면 넘어감
	for(int j = i * i; j < MAX_NUM; j += i)
	// 초기값이 i*i인 이뉴는, 이미 이전 단계에서 i(i-1)까지의 모든 수가 지워져있기 때문.
		sieve[j] = 1;	//지워지지 않은 i의 배수를 모두 지워준다.
}

printf("%d이상 %d미만의 소수\n");
for(int i = 2; i<MAX_NUM; ++i)
	if(!sieve[i]) printf("%d\n", i);
```	

## 🛸이분 탐색(binary search)
: 이미 정렬된 배열에서 특정한 원소가 포함되어 있는지 아닌지를 빠르게 판단할 수 있는 기법.
### 판단 순서
1. 값 A를 찾고자 할 때, 값이 포함된 것으로 예상되는 범위의 가운데 값을 먼저 확인한다.
2. A와 가운데 원소를 비교해 A가 있을 수 없는 곳은 탐색하지 않고 지나간다.
``` c++
int binary_search(vector<int>& seq, int data) {
	int l = 0, r = seq.size() - 1;
	while (l <= r) {
		int mid = (l + r) / 2;
		if (seq[mid] == data)
			return mid;
		else if (seq[mid] < data)
			l = mid + 1;
		else
			r = mid - 1;
	}
	return -1;
}
```
### When?
: 정렬된 배열에서 특정한 원소를 찾기 위해 사용될 뿐만 아니라, 어떤 문제를 풀면서 __답을 직접 구하기는 어렵지만, 답을 가정할 수 있고 해당 답이 맞는지 틀린지 확인하는 문제에서 자주 사용__ 된다.